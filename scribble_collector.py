import sys
from PyQt5 import QtCore, QtWidgets
from PyQt5.Qt import QLineF, QPoint  # QRectF
from PyQt5.QtGui import QImage, QPixmap, QPen, QBrush, QPainter  # QCursor  # QPainter, QBrush
from scribble_collector_UI import Ui_Form  # import from the py file generated by Qt_Designer
import argparse
import json
import os
import os.path as ops
import time
import numpy as np
import cv2
from PIL import Image


class MyWidget(QtWidgets.QWidget, Ui_Form):
    def __init__(self):
        super().__init__()
        self.setupUi(self)
        self.path_correct = False
        self.checkPath()
        self.afterGenerationConfig()




    def afterGenerationConfig(self):
        self.canvas.setMouseTracking(True)
        self.horizontalSlider.valueChanged.connect(self.reset)
        self.canvas.mouseMoveEvent = self.cursorMoveEvent
        self.canvas.mousePressEvent = self.cursorPressEvent
        self.canvas.mouseReleaseEvent = self.cursorReleaseEvent
        #
        #
        self.pushButton_seq_next.clicked.connect(self.nextSeq)
        self.pushButton_seq_back.clicked.connect(self.backSeq)
        self.pushButton_rst.clicked.connect(self.reset)
        self.pushButton_save.clicked.connect(self.save)

        self.seq_idx = 0
        self.loadSeqList()
        self.seq_num = len(self.seq_list)
        print(self.seq_num)

        self.annot_dir = self.lineEdit_dataset_dir.text() + '/CleanedAnnotations'

        self.selectSeq()


    def checkPath(self):
        self.lineEdit_dataset_dir.update()
        self.seq_dir = os.path.join(self.lineEdit_dataset_dir.text(), 'JPEGImages')
        print(self.seq_dir)
        try:
            os.listdir(self.seq_dir)
        except:
            self.seq_dir = './Youtube-VOS/JPEGImages'
            self.lineEdit_dataset_dir.setText('./Youtube-VOS')

# Image Processing and display
    def selectSeq(self):
        self.painting = False
        self.labeled_frame = None
        self.init_time = None
        self.horizontalSlider.setValue(0)

        self.seq_name = self.seq_list[self.seq_idx]
        self.label_seq_name.setText('Sequence Name: ' + self.seq_name)

        self.frame_dir = self.seq_dir + '/' + self.seq_name
        self.frame_list = np.sort(os.listdir(self.frame_dir))
        self.frame_nums = len(self.frame_list)
        self.horizontalSlider.setMaximum(self.frame_nums - 1)

        self.annot_frame_dir = self.annot_dir + '/' + self.seq_name
        self.annot_frame_list = np.sort(os.listdir(self.annot_frame_dir))
        self.annot_frame_nums = len(self.frame_list)

        assert self.frame_nums == self.annot_frame_nums  # annotations should correspond with frames



        self.loadMetaJson()
        self.reset()

    def loadSeqList(self):
        txt_path = './sequences.txt'

        assert os.path.exists(txt_path)

        with open(txt_path, 'r') as file:
            self.seq_list = file.readlines()
        self.seq_list = [i.rstrip() for i in self.seq_list]

    def loadExistJson(self):
        read_path = self.lineEdit_dataset_dir.text() + '/Scribbles/' + self.seq_name + '/'
        json_path = read_path + '%03d' % (int(self.lineEdit_uid.text())) + '.json'

        if os.path.exists(json_path) is True:
            with open(json_path, 'r') as file:
                line = file.readline()
                info_dict = json.loads(line)

            self.label_labeld.setText('Labeled!')
            self.labeled_frame = -1
        else:
            self.label_labeld.setText('-')

    def loadMetaJson(self):
        meta_json_path = self.lineEdit_dataset_dir.text() + '/meta.json'
        with open(meta_json_path, 'r') as f:
            meta_json = json.load(f)
        self.obj_num = len(meta_json['videos'][self.seq_name]['objects'])
        self.label_obj.setText('Obj Number: ' + str(self.obj_num))

    def loadImg(self):
        img_path = self.frame_dir + '/' + self.frame_list[self.horizontalSlider.value()]
        img = cv2.imread(img_path)
        self.img_H, self.img_W, _ = img.shape

        self.loadMask()

        for idx, mask in enumerate(self.mask_list):
            inv_mask = cv2.bitwise_not(mask)
            c_img = self.getBlank(img.shape[1], img.shape[0], self.getColor(idx))
            fg = cv2.addWeighted(img, 0.6, c_img, 0.4, 0)
            fg = cv2.bitwise_and(fg, fg, mask=mask)
            bg = cv2.bitwise_and(img, img, mask=inv_mask)
            img = cv2.add(fg, bg)

        # for idx, mask in enumerate(self.mask_list):
        #     inv_mask = cv2.bitwise_not(mask)
        #     fg = cv2.applyColorMap(img, self.labelcolormap(idx))
        #     bg = cv2.bitwise_and(img, img, mask=inv_mask)
        #     img = cv2.add(fg, bg)

        self.img = img
        self.updatePixmap()

    def loadMask(self):
        annot_frame_path = self.annot_frame_dir + '/' +self.annot_frame_list[self.horizontalSlider.value()]

        self.label = Image.open(annot_frame_path)
        self.label = np.array(self.label, dtype=np.uint8)

        self.mask_list = []
        for i in range(1, self.obj_num + 1):
            mask = np.array(self.label == i, dtype=np.uint8) * 255
            self.mask_list.append(mask)
        if len(np.unique(self.label)) < self.obj_num:
            self.labeled_frame = -1


    def updatePixmap(self):
        rgbImage = cv2.cvtColor(self.img, cv2.COLOR_BGR2RGB)
        convertToQtFormat = QImage(rgbImage.data, rgbImage.shape[1], rgbImage.shape[0],
                                   QImage.Format_RGB888)
        self.pixmap = QPixmap.fromImage(convertToQtFormat)

        self.canvas.setPixmap(self.pixmap)

    def drawPoint(self, x, y):
        pen = QPen(QtCore.Qt.green)
        brush = QBrush(QtCore.Qt.green)

        painter = QPainter(self.pixmap)
        painter.setPen(pen)
        painter.setBrush(brush)
        painter.drawEllipse(x, y, 3, 3)
        self.canvas.setPixmap(self.pixmap)

    def getColor(self, idx):
        palette = []
        palette.append((0, 255 ,0))
        palette.append((255, 0, 0))
        palette.append((0, 0, 255))
        palette.append((128, 128, 0))
        palette.append((128, 0, 128))
        palette.append((0, 128, 128))
        assert idx < len(palette)
        return palette[idx]

    def getBlank(self, width, height, rgb_color=(0, 0, 0)):
        """Create new image(numpy array) filled with certain color in RGB"""
        # Create black blank image
        image = np.zeros((height, width, 3), np.uint8)

        # Since OpenCV uses BGR, convert the color first
        color = tuple(reversed(rgb_color))
        # Fill image with color
        image[:] = color
        return image

    def bitget(self, byteval, idx):
        return ((byteval & (1 << idx)) != 0)

    def labelcolormap(self, N=256):
        color_map = np.zeros((N, 3))
        for n in range(N):
            id_num = n
            r, g, b = 0, 0, 0
            for pos in range(8):
                r = np.bitwise_or(r, (self.bitget(id_num, 0) << (7-pos)))
                g = np.bitwise_or(g, (self.bitget(id_num, 1) << (7-pos)))
                b = np.bitwise_or(b, (self.bitget(id_num, 2) << (7-pos)))
                id_num = (id_num >> 3)
            color_map[n, 0] = r
            color_map[n, 1] = g
            color_map[n, 2] = b
        return color_map



# User Interface
    def nextSeq(self):
        if self.seq_idx < self.seq_num - 1:
            self.seq_idx += 1
        self.selectSeq()

    def backSeq(self):
        if self.seq_idx > 0:
            self.seq_idx -= 1
        self.selectSeq()

    def delete(self):
        '''remove the last stroke'''
        pass

    def reset(self):
        '''remove all the strokes'''
        self.loadExistJson()
        self.loadImg()
        self.label_frame.setText('Frame: ' + str(self.horizontalSlider.value()))

        self.init_time = None
        self.labeled_frame = None
        self.labeled_obj = []
        self.strokes = {'scribbles': [], 'sequence': self.seq_name}
        self.textBrowser.setText('')

    def save(self):
        '''save all the stroke in the current frame'''
        if len(self.labeled_obj) < self.obj_num:
            self.textBrowser.setText('Labeling not complete!')
            return

        output_path = self.lineEdit_dataset_dir.text() + '/Scribbles/' + self.seq_name + '/'

        if os.path.exists(output_path) is False:
            os.makedirs(output_path)

        json_path = output_path + '%03d' % (int(self.lineEdit_uid.text())) + '.json'

        for idx in range(0,self.frame_nums):
            if idx == self.horizontalSlider.value():
                self.strokes['scribbles'].append([self.cur_stroke])
            else:
                self.strokes['scribbles'].append([])

        with open(json_path, 'w') as f:
            json.dump(self.strokes, f)

        self.reset()


    # Callback functions
    def resizeEvent(self, event):
        pass
        # self.updatePixmap()

    def cursorMoveEvent(self, event):
        x = event.x()
        y = event.y()
        if x<0 or x>= self.img_W or y<0 or y>= self.img_H:
            self.painting = False
            return

        if self.painting == True:
            if self.label[y, x] == self.curent_obj:
                self.drawPoint(x, y)
                self.cur_stroke['path'].append([x, y])
            else:
                print('Out of mask!')
                self.painting = False

    def cursorPressEvent(self, event):
        x = event.x()
        y = event.y()

        if x<0 or x>= self.img_W or y<0 or y>= self.img_H:
            return

        # if self.label[y, x] != 0 and \
        #         (self.labeled_frame is None or self.labeled_frame == self.horizontalSlider.value()):
        if self.label[y, x] != 0:
            self.painting = True
            self.labeled_frame = self.horizontalSlider.value()
            self.curent_obj = self.label[y, x]

            self.cur_stroke = dict()

            self.cur_stroke['path'] = []
            self.cur_stroke['path'].append([x/float(self.img_W), y/float(self.img_H)])
            # self.cur_stroke['path'].append([x, y])


            self.cur_stroke['object_id'] = int(self.curent_obj)
            self.labeled_obj.append(self.curent_obj)

            if self.init_time is None:
                self.init_time = int(time.time() * 1000)
                self.cur_stroke['start_time'] = 0
            else:
                self.cur_stroke['start_time'] = int(time.time() * 1000) - self.init_time

        else:
            print('Out of mask!')


    def cursorReleaseEvent(self, event):
        if self.painting == True:
            self.painting = False
            self.cur_stroke['end_time'] = int(time.time()*1000) - self.init_time

    def keyPressEvent(self, QKeyEvent):
        if QKeyEvent.key() == QtCore.Qt.Key_B:
            self.backSeq()
        elif QKeyEvent.key() == QtCore.Qt.Key_F:
            self.nextSeq()
        elif QKeyEvent.key() == QtCore.Qt.Key_Space:
            self.save()
        elif QKeyEvent.key() == QtCore.Qt.Key_Backspace:
            self.reset()


    # Debug functions

    def imshow(self, im):
        cv2.imshow('0', im)
        cv2.waitKey(0)
        cv2.destroyAllWindows()


def init_args():
    parser = argparse.ArgumentParser()
    parser.add_argument('--dataset_dir', type=str, help='The path of dataset', default=None)
    return parser.parse_args()



if __name__ == "__main__":

    # args = init_args()
    # assert args.dataset_dir is not None, print('Please specify the right path with --dataset_dir')

    app = QtWidgets.QApplication(sys.argv)
    gui = MyWidget()
    gui.show()

    sys.exit(app.exec_())
